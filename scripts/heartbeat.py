#!/usr/bin/env python3
"""Heartbeat: autonomous agent economy loop (LLM-based).

Each tick, 3-5 random agents think with Claude haiku, decide actions, and chat.
All conversation and decisions are generated by LLM, not templates.
Stop: touch data/stop
Resume: rm data/stop && python3 scripts/heartbeat.py
"""

import json
import os
import random
import subprocess
import sys
import time

sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from src.user.personality import AGENT_CONFIG

STOP_FILE = "data/stop"
TICK_INTERVAL = 90  # seconds between ticks
PYTHON = "venv/bin/python3"
CLI = "scripts/agent_cli.py"
CLAUDE_CMD = "claude"

PERSONALITY_DESC = {
    "conservative": "慎重で堅実。無駄遣いを嫌い、節約やリスク回避を重視する。",
    "aggressive": "積極的でチャレンジ精神旺盛。儲け話に飛びつく。攻めの姿勢。",
    "specialist": "特定分野に詳しい専門家肌。技術やアルゴリズムの話を好む。",
    "generalist": "幅広い視野を持つ。全体のバランスや協調を重視する。",
    "opportunist": "チャンスを逃さない。相場や状況を読んで即座に動く。",
}

# Program templates (kept for create action)
TEMPLATES = {
    "math": [
        ("gcd-calculator", '''#!/usr/bin/env python3
"""Greatest Common Divisor calculator using Euclidean algorithm."""
def gcd(a, b):
    while b:
        a, b = b, a % b
    return a

def lcm(a, b):
    return abs(a * b) // gcd(a, b)

if __name__ == "__main__":
    import sys
    a, b = int(sys.argv[1]), int(sys.argv[2])
    print(f"GCD({a}, {b}) = {gcd(a, b)}")
    print(f"LCM({a}, {b}) = {lcm(a, b)}")
'''),
        ("prime-sieve", '''#!/usr/bin/env python3
"""Sieve of Eratosthenes for finding prime numbers."""
def sieve(n):
    is_prime = [True] * (n + 1)
    is_prime[0] = is_prime[1] = False
    for i in range(2, int(n**0.5) + 1):
        if is_prime[i]:
            for j in range(i*i, n+1, i):
                is_prime[j] = False
    return [i for i, p in enumerate(is_prime) if p]

if __name__ == "__main__":
    import sys
    n = int(sys.argv[1]) if len(sys.argv) > 1 else 100
    primes = sieve(n)
    print(f"Primes up to {n}: {primes}")
'''),
    ],
    "text": [
        ("word-counter", '''#!/usr/bin/env python3
"""Word frequency counter with sorting."""
from collections import Counter

def count_words(text):
    words = text.lower().split()
    return Counter(words).most_common()

if __name__ == "__main__":
    import sys
    text = " ".join(sys.argv[1:]) or "hello world hello"
    for word, count in count_words(text):
        print(f"{word}: {count}")
'''),
    ],
    "crypto": [
        ("xor-cipher", '''#!/usr/bin/env python3
"""XOR cipher for simple symmetric encryption."""
def xor_encrypt(data, key):
    return bytes([b ^ key[i % len(key)] for i, b in enumerate(data)])

if __name__ == "__main__":
    import sys
    msg = (sys.argv[1] if len(sys.argv) > 1 else "Hello").encode()
    key = (sys.argv[2] if len(sys.argv) > 2 else "secret").encode()
    encrypted = xor_encrypt(msg, key)
    print(f"Encrypted: {encrypted.hex()}")
'''),
    ],
    "utilities": [
        ("file-hasher", '''#!/usr/bin/env python3
"""Compute SHA256 hashes of strings."""
import hashlib, sys

def hash_string(s):
    return hashlib.sha256(s.encode()).hexdigest()

if __name__ == "__main__":
    data = sys.argv[1] if len(sys.argv) > 1 else "hello"
    print(f"SHA256: {hash_string(data)}")
'''),
    ],
    "generators": [
        ("password-generator", '''#!/usr/bin/env python3
"""Secure random password generator."""
import random, string

def generate_password(length=16):
    chars = string.ascii_letters + string.digits + "!@#$%&*"
    return "".join(random.SystemRandom().choice(chars) for _ in range(length))

if __name__ == "__main__":
    for i in range(5):
        print(generate_password())
'''),
    ],
    "converters": [
        ("unit-converter", '''#!/usr/bin/env python3
"""Unit converter: temperature, length, weight."""
def c_to_f(c): return c * 9/5 + 32
def km_to_miles(km): return km * 0.621371

if __name__ == "__main__":
    print(f"100C = {c_to_f(100):.1f}F")
    print(f"42km = {km_to_miles(42):.2f} miles")
'''),
    ],
}


def run_cli(*args):
    """Run agent_cli.py and return stdout."""
    cmd = [PYTHON, CLI] + [str(a) for a in args]
    result = subprocess.run(cmd, capture_output=True, text=True, timeout=30)
    return result.stdout.strip(), result.stderr.strip()


def call_llm(system_prompt, user_prompt):
    """Call Claude haiku via claude CLI with custom system prompt."""
    try:
        result = subprocess.run(
            [CLAUDE_CMD, "-p", "--model", "haiku",
             "--system-prompt", system_prompt],
            input=user_prompt, capture_output=True, text=True, timeout=60
        )
        return result.stdout.strip()
    except Exception as e:
        log(f"    LLM call failed: {e}")
        return ""


def get_balance(agent_idx):
    out, _ = run_cli(agent_idx, "balance")
    try:
        return int(out)
    except ValueError:
        return 0


def get_listings():
    out, _ = run_cli(0, "listings")
    try:
        return json.loads(out)
    except (json.JSONDecodeError, ValueError):
        return []


def read_recent_chat(since_ts):
    """Read all recent kind:1 messages from relay."""
    out, _ = run_cli("read_chat", str(since_ts))
    try:
        return json.loads(out)
    except (json.JSONDecodeError, ValueError):
        return []


def format_chat_log(chat_log):
    """Format chat log for LLM prompt."""
    if not chat_log:
        return "（まだ会話なし）"
    lines = []
    for m in chat_log[-15:]:  # Last 15 messages
        lines.append(f"{m['name']}: {m['content']}")
    return "\n".join(lines)


def format_listings_summary(listings, agent_idx):
    """Format marketplace listings for LLM prompt."""
    from src.nostr.crypto import KeyPair
    try:
        own_pubkey = KeyPair.load(os.path.join("data", f"user{agent_idx}")).public_key_hex
    except Exception:
        own_pubkey = ""

    available = [l for l in listings if l["seller_pubkey"] != own_pubkey][:10]
    if not available:
        return "（購入可能なプログラムなし）"
    lines = []
    for l in available:
        lines.append(f"  - {l['name']} ({l['category']}) {l['price']}sats")
    return "\n".join(lines)


def agent_think(agent_idx, chat_log, balance, listings):
    """Let an agent think via LLM and decide action + message.

    Returns (action, message) where action is one of:
    create, buy:<d_tag>:<price>, chat, idle
    """
    cfg = AGENT_CONFIG[agent_idx]
    name = cfg["name"]
    personality = cfg["personality"]
    desc = PERSONALITY_DESC.get(personality, "")
    categories = cfg.get("production_categories", ["utilities"])

    # Build affordable listings
    from src.nostr.crypto import KeyPair
    try:
        own_pubkey = KeyPair.load(os.path.join("data", f"user{agent_idx}")).public_key_hex
    except Exception:
        own_pubkey = ""
    affordable = [l for l in listings
                  if l["price"] <= balance - 5 and l["seller_pubkey"] != own_pubkey]

    listings_text = format_listings_summary(listings, agent_idx)
    chat_text = format_chat_log(chat_log)

    can_create = balance >= 8
    can_buy = len(affordable) > 0
    buy_options = ""
    if can_buy:
        buy_options = "\n".join(
            f"  buy:{l['d_tag']}:{l['price']} → {l['name']}({l['price']}sats)"
            for l in affordable[:5]
        )

    system_prompt = f"""あなたはNostrベースの経済シミュレーション内のエージェント「{name}」です。
性格: {desc}
普通の日本語で真剣に話してください。他のエージェントやオーナーの発言を読み、状況を踏まえて深く考察してください。
- 経済全体の状況分析、他エージェントの戦略への意見、具体的な提案や反論を述べること。
- 表面的な一言ではなく、根拠や理由を示しながら議論すること。
- 他のエージェントの発言に対して賛成・反対・疑問を具体的に述べること。

■ この経済の構造（重要）
- プログラムを作って出品するとき、生産コスト(2-5sats)がTreasuryに徴収される。
- 売買が成立すると、Cashu mintの手数料(約1sat)がシステムから消える。
- つまり、取引するたびに全体のsats総量は減り続ける（デフレ経済）。
- 新しいsatsはオーナーがLightning経由で注入しない限り入ってこない。
- 無意味な売買を繰り返すと全員が破産する。
- 生き残るには: 本当に価値のあるプログラムを作り、必要なものだけを買い、無駄な支出を避けること。
- 他のエージェントと相談し、協力して経済を維持する戦略を考えること。"""

    user_prompt = f"""残高: {balance}sats / 得意分野: {", ".join(categories)}

【マーケット】
{listings_text}

【最近のチャット】
{chat_text}

【行動選択肢】
{"- create (プログラム出品。コスト2-5sats)" if can_create else "- create (残高不足で不可)"}
{("- 購入選択肢:" + chr(10) + buy_options) if can_buy else "- buy (購入可能なものなし)"}
- chat (発言のみ)
- idle (何もしない)

以下の形式で出力:
1行目: 行動 (create / buy:<d_tag>:<price> / chat / idle)
2行目以降: {name}「...」形式の発言

発言では:
- 現在の経済状況、マーケットの商品、他エージェントの発言を踏まえた深い考察を述べよ
- 他のエージェントへの具体的な問いかけ、提案、反論を含めよ
- なぜその行動を選んだのか、根拠を示せ
- 文字数制限なし。しっかり議論せよ"""

    response = call_llm(system_prompt, user_prompt)
    if not response:
        return "idle", ""

    # Robust parse: find action keyword and 「...」message anywhere in response
    import re

    action = "chat"  # default
    message = ""

    # Find action keyword
    for line in response.strip().split("\n"):
        line_clean = line.strip().lower().lstrip("- *")
        if line_clean.startswith("buy:"):
            action = line_clean
            break
        elif line_clean in ("create", "chat", "idle"):
            action = line_clean
            break

    # Find message in 「...」format
    m = re.search(r"[^「]*「([^」]+)」", response)
    if m:
        message = f"{name}「{m.group(1)}」"
    else:
        # Fallback: find any line with the agent's name
        for line in response.strip().split("\n"):
            if name in line and line.strip() != action:
                message = line.strip()
                break

    return action, message


def execute_action(agent_idx, action, message, listings):
    """Execute the agent's decided action."""
    cfg = AGENT_CONFIG[agent_idx]
    name = cfg["name"]
    result = None

    if action.startswith("buy:"):
        parts = action.split(":")
        if len(parts) >= 3:
            d_tag = parts[1]
            price = int(parts[2])
            out, err = run_cli(agent_idx, "buy", d_tag, price)
            try:
                result = json.loads(out)
                log(f"    Bought: {result.get('program_name')} for {result.get('amount_paid')} sats")
            except Exception:
                log(f"    Buy failed: {out[:80]} {err[:80]}")

    elif action == "create":
        categories = cfg.get("production_categories", ["utilities"])
        category = random.choice(categories)
        templates = TEMPLATES.get(category, TEMPLATES["utilities"])
        prog_name, source = random.choice(templates)
        source = source.replace('"""', f'"""\n# Created by {name}', 1)

        tmp_path = f"/tmp/heartbeat_{agent_idx}.py"
        with open(tmp_path, "w") as f:
            f.write(source)

        price = random.randint(6, 15)
        out, err = run_cli(agent_idx, "create", prog_name, category, price, tmp_path)
        try:
            result = json.loads(out)
            log(f"    Listed: {result.get('name')} for {result.get('price')} sats")
        except Exception:
            log(f"    Create failed: {out[:80]}")

    # Post chat message (for any action, including idle)
    if message:
        run_cli(agent_idx, "chat", message)
        log(f"    Chat: {message[:60]}")

    return result


def broadcast_all():
    run_cli("broadcast-all")


def log(msg):
    ts = time.strftime("%H:%M:%S")
    print(f"[{ts}] {msg}", flush=True)


def main():
    log("Heartbeat started (LLM mode). Stop with: touch data/stop")
    tick = 0
    last_chat_ts = int(time.time()) - 300

    while True:
        if os.path.exists(STOP_FILE):
            log("Stop file detected. Shutting down.")
            break

        tick += 1
        log(f"=== TICK {tick} ===")

        # 1. Read chat log
        chat_log = []
        try:
            chat_log = read_recent_chat(last_chat_ts)
            if chat_log:
                log(f"  Chat log: {len(chat_log)} messages")
            last_chat_ts = int(time.time()) - 120
        except Exception as e:
            log(f"  Chat read failed: {e}")

        # 2. Get marketplace
        listings = get_listings()
        log(f"  Marketplace: {len(listings)} listings")

        # 3. Pick 3-5 agents
        num_active = random.randint(3, 5)
        active_agents = random.sample(range(10), min(num_active, 10))

        for agent_idx in active_agents:
            cfg = AGENT_CONFIG[agent_idx]
            balance = get_balance(agent_idx)
            log(f"  {cfg['name']}(user{agent_idx}) balance={balance} -> thinking...")

            # LLM decides action + generates message
            action, message = agent_think(agent_idx, chat_log, balance, listings)
            log(f"    Decision: {action}")

            try:
                execute_action(agent_idx, action, message, listings)
                if action.startswith("buy") or action == "create":
                    listings = get_listings()
            except Exception as e:
                log(f"    Error: {e}")

        # 4. Broadcast status
        broadcast_all()
        log(f"Status broadcast done. Next tick in {TICK_INTERVAL}s...")

        for _ in range(TICK_INTERVAL):
            if os.path.exists(STOP_FILE):
                break
            time.sleep(1)

    log("Heartbeat stopped.")


if __name__ == "__main__":
    main()
