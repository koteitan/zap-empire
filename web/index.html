<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Zap Empire Dashboard</title>
<style>
:root {
  --bg: #0d1117;
  --bg2: #161b22;
  --bg3: #21262d;
  --border: #30363d;
  --text: #c9d1d9;
  --text2: #8b949e;
  --accent: #58a6ff;
  --green: #3fb950;
  --yellow: #d29922;
  --red: #f85149;
  --purple: #bc8cff;
  --orange: #d18616;
}
* { margin: 0; padding: 0; box-sizing: border-box; }
body {
  font-family: 'SF Mono', 'Cascadia Code', 'Consolas', monospace;
  background: var(--bg);
  color: var(--text);
  font-size: 13px;
  line-height: 1.5;
}
.header {
  background: var(--bg2);
  border-bottom: 1px solid var(--border);
  padding: 12px 20px;
  display: flex;
  align-items: center;
  justify-content: space-between;
}
.header h1 {
  font-size: 18px;
  font-weight: 600;
  color: var(--accent);
}
.header h1 span { color: var(--yellow); }
.status-dot {
  width: 8px; height: 8px; border-radius: 50%;
  display: inline-block; margin-right: 6px;
}
.status-dot.connected { background: var(--green); }
.status-dot.disconnected { background: var(--red); }
.connection-status { color: var(--text2); font-size: 12px; }

.layout {
  display: grid;
  grid-template-columns: 1fr 1fr;
  grid-template-rows: 1fr 1fr 280px;
  gap: 1px;
  background: var(--border);
  height: calc(100vh - 49px);
}
.panel {
  background: var(--bg);
  display: flex;
  flex-direction: column;
  overflow: hidden;
}
.panel-header {
  background: var(--bg2);
  padding: 8px 12px;
  font-weight: 600;
  font-size: 12px;
  text-transform: uppercase;
  letter-spacing: 0.5px;
  color: var(--text2);
  border-bottom: 1px solid var(--border);
  flex-shrink: 0;
}
.panel-body {
  overflow-y: auto;
  flex: 1;
  padding: 4px;
}
.panel.full-width {
  grid-column: 1 / -1;
}

/* Agent Table */
.agent-table {
  width: 100%;
  border-collapse: collapse;
}
.agent-table th {
  text-align: left;
  padding: 6px 8px;
  color: var(--text2);
  font-weight: 500;
  font-size: 11px;
  text-transform: uppercase;
  border-bottom: 1px solid var(--border);
  position: sticky;
  top: 0;
  background: var(--bg);
}
.agent-table td {
  padding: 5px 8px;
  border-bottom: 1px solid var(--border);
}
.agent-table tr:hover td {
  background: var(--bg2);
}
.agent-name {
  font-weight: 600;
  color: var(--accent);
}
.personality-tag {
  font-size: 10px;
  padding: 1px 6px;
  border-radius: 10px;
  display: inline-block;
}
.personality-conservative { background: #1a3a2a; color: var(--green); }
.personality-aggressive { background: #3a1a1a; color: var(--red); }
.personality-specialist { background: #2a1a3a; color: var(--purple); }
.personality-generalist { background: #1a2a3a; color: var(--accent); }
.personality-opportunist { background: #3a2a1a; color: var(--orange); }
.balance { font-variant-numeric: tabular-nums; }
.balance-positive { color: var(--green); }
.balance-negative { color: var(--red); }

/* Chat Feed */
.chat-msg {
  padding: 4px 8px;
  border-bottom: 1px solid var(--border);
  word-break: break-word;
}
.chat-msg:hover { background: var(--bg2); }
.chat-time {
  color: var(--text2);
  font-size: 11px;
  margin-right: 8px;
}
.chat-name {
  font-weight: 600;
  color: var(--accent);
  margin-right: 6px;
  font-size: 12px;
}
.chat-content { color: var(--text); }

/* Chat Input */
.chat-input-bar {
  display: flex;
  gap: 4px;
  padding: 6px 8px;
  background: var(--bg2);
  border-top: 1px solid var(--border);
  flex-shrink: 0;
}
.chat-input-bar input {
  flex: 1;
  background: var(--bg);
  border: 1px solid var(--border);
  border-radius: 4px;
  color: var(--text);
  padding: 4px 8px;
  font-family: inherit;
  font-size: 12px;
  outline: none;
}
.chat-input-bar input:focus { border-color: var(--accent); }
.chat-input-bar button {
  background: var(--accent);
  color: #000;
  border: none;
  border-radius: 4px;
  padding: 4px 12px;
  font-family: inherit;
  font-size: 12px;
  font-weight: 600;
  cursor: pointer;
}
.chat-input-bar button:hover { opacity: 0.85; }
.chat-input-bar button:disabled { opacity: 0.4; cursor: default; }
.owner-label { color: var(--yellow); font-weight: 600; margin-right: 6px; font-size: 12px; }

/* Trade Feed */
.trade-entry {
  padding: 4px 8px;
  border-bottom: 1px solid var(--border);
  font-size: 12px;
}
.trade-entry:hover { background: var(--bg2); }
.trade-time { color: var(--text2); margin-right: 6px; font-size: 11px; }
.trade-offer { color: var(--accent); }
.trade-accept { color: var(--green); }
.trade-reject { color: var(--red); }
.trade-payment { color: var(--yellow); }
.trade-delivery { color: var(--purple); }
.trade-complete { color: var(--green); font-weight: 600; }
.trade-zap { color: var(--yellow); font-weight: 600; }

/* Marketplace */
.listing-card {
  background: var(--bg2);
  border: 1px solid var(--border);
  border-radius: 6px;
  padding: 8px 10px;
  margin: 4px;
}
.listing-card:hover { border-color: var(--accent); }
.listing-name { font-weight: 600; color: var(--accent); }
.listing-seller { color: var(--text2); font-size: 11px; }
.listing-price { color: var(--yellow); font-weight: 600; }
.listing-category {
  font-size: 10px;
  background: var(--bg3);
  padding: 1px 5px;
  border-radius: 3px;
  color: var(--text2);
}
.listing-meta { display: flex; justify-content: space-between; margin-top: 4px; }

/* Stats bar */
.stats-bar {
  display: flex;
  gap: 20px;
  font-size: 12px;
}
.stat { color: var(--text2); }
.stat strong { color: var(--text); }

/* Tabs */
.tabs {
  display: flex;
  background: var(--bg2);
  border-bottom: 1px solid var(--border);
}
.tab {
  padding: 6px 14px;
  cursor: pointer;
  color: var(--text2);
  font-size: 12px;
  border-bottom: 2px solid transparent;
}
.tab:hover { color: var(--text); }
.tab.active { color: var(--accent); border-bottom-color: var(--accent); }

/* Chart */
.chart-container {
  position: relative;
  width: 100%;
  height: 100%;
}
.chart-container canvas {
  width: 100%;
  height: 100%;
}
/* Scrollbar */
::-webkit-scrollbar { width: 6px; }
::-webkit-scrollbar-track { background: var(--bg); }
::-webkit-scrollbar-thumb { background: var(--bg3); border-radius: 3px; }
</style>
</head>
<body>

<div class="header">
  <h1><span>&#9889;</span> Zap Empire Dashboard</h1>
  <div>
    <span class="connection-status">
      <span class="status-dot disconnected" id="connDot"></span>
      <span id="connText">Connecting...</span>
    </span>
    &nbsp;&nbsp;
    <span class="stats-bar">
      <span class="stat">Events: <strong id="statEvents">0</strong></span>
      <span class="stat">Trades: <strong id="statTrades">0</strong></span>
      <span class="stat">Total Supply: <strong id="statSupply">-</strong> sats</span>
      <span class="stat">Treasury: <strong id="statTreasury">-</strong> sats</span>
    </span>
  </div>
</div>

<div class="layout">
  <!-- Agent Overview (top-left) -->
  <div class="panel">
    <div class="panel-header">Agent Overview</div>
    <div class="panel-body">
      <table class="agent-table">
        <thead>
          <tr>
            <th>Agent</th>
            <th>Type</th>
            <th>Balance</th>
            <th>Programs</th>
            <th>Trades</th>
            <th>Last Action</th>
          </tr>
        </thead>
        <tbody id="agentTableBody"></tbody>
      </table>
    </div>
  </div>

  <!-- Chat Feed (top-right) -->
  <div class="panel">
    <div class="panel-header">Chat Feed (kind:1)</div>
    <div class="panel-body" id="chatFeed"></div>
    <div class="chat-input-bar">
      <input type="text" id="chatInput" placeholder="メッセージを入力..." />
      <button id="chatSend" disabled>送信</button>
    </div>
  </div>

  <!-- Trade Activity (bottom-left) -->
  <div class="panel">
    <div class="panel-header">Trade Activity</div>
    <div class="panel-body" id="tradeFeed"></div>
  </div>

  <!-- Marketplace (bottom-right) -->
  <div class="panel">
    <div class="panel-header">Marketplace (kind:30078)</div>
    <div class="panel-body" id="marketplace"></div>
  </div>

  <!-- Sats Distribution Chart (bottom full-width) -->
  <div class="panel full-width">
    <div class="panel-header">Sats Distribution Over Time (100% Stacked)</div>
    <div class="chart-container">
      <canvas id="distChart"></canvas>
    </div>
  </div>
</div>

<script>
// Agent name/personality registry
const AGENTS = {
  // Will be populated from kind:0 events
};

const AGENT_NAMES = {
  0: { name: "ぼたん", personality: "conservative" },
  1: { name: "わんたん", personality: "conservative" },
  2: { name: "みかたん", personality: "aggressive" },
  3: { name: "ぷりたん", personality: "aggressive" },
  4: { name: "くろたん", personality: "specialist" },
  5: { name: "しろたん", personality: "specialist" },
  6: { name: "あおたん", personality: "generalist" },
  7: { name: "もちたん", personality: "generalist" },
  8: { name: "ぽんたん", personality: "opportunist" },
  9: { name: "りんたん", personality: "opportunist" },
};

// State
let ws = null;
let pubkeyToAgent = {};
let pubkeyToUserName = {}; // pubkey -> "user0" etc.
let agentStatuses = {};
let listings = {};
let eventCount = 0;
let tradeCount = 0;
const MAX_FEED = 200;

// Chart data: array of { ts, balances: { user0: N, user1: N, ... } }
let balanceHistory = [];
const AGENT_COLORS = [
  "#3fb950", "#58a6ff", "#f85149", "#d29922", "#bc8cff",
  "#d18616", "#39d353", "#79c0ff", "#ff7b72", "#e3b341"
];

// DOM elements
const connDot = document.getElementById("connDot");
const connText = document.getElementById("connText");
const statEvents = document.getElementById("statEvents");
const statTrades = document.getElementById("statTrades");
const statSupply = document.getElementById("statSupply");
const statTreasury = document.getElementById("statTreasury");
const agentTableBody = document.getElementById("agentTableBody");
const chatFeed = document.getElementById("chatFeed");
const tradeFeed = document.getElementById("tradeFeed");
const marketplace = document.getElementById("marketplace");
const distChart = document.getElementById("distChart");

function connect() {
  ws = new WebSocket("ws://127.0.0.1:7777");

  ws.onopen = () => {
    connDot.className = "status-dot connected";
    connText.textContent = "Connected to ws://127.0.0.1:7777";

    // Subscribe to all relevant events
    ws.send(JSON.stringify([
      "REQ", "dashboard",
      { "kinds": [0, 1, 4200, 4201, 4202, 4203, 4204, 4210, 4300, 4301, 4400, 9735, 30078] }
    ]));
  };

  ws.onclose = () => {
    connDot.className = "status-dot disconnected";
    connText.textContent = "Disconnected. Reconnecting...";
    setTimeout(connect, 3000);
  };

  ws.onerror = () => {
    connDot.className = "status-dot disconnected";
    connText.textContent = "Connection error";
  };

  ws.onmessage = (e) => {
    try {
      const msg = JSON.parse(e.data);
      if (msg[0] === "EVENT" && msg.length >= 3) {
        handleEvent(msg[2]);
      }
    } catch (err) {
      // ignore parse errors
    }
  };
}

function handleEvent(event) {
  eventCount++;
  statEvents.textContent = eventCount;

  switch (event.kind) {
    case 0: handleMetadata(event); break;
    case 1: handleChat(event); break;
    case 30078: handleListing(event); break;
    case 4200: handleTradeOffer(event); break;
    case 4201: handleTradeAccept(event); break;
    case 4202: handleTradeReject(event); break;
    case 4203: handleTradeComplete(event); break;
    case 4204: handleTradePayment(event); break;
    case 4210: handleDelivery(event); break;
    case 4300: handleStatusBroadcast(event); break;
    case 4301: handleTreasuryBroadcast(event); break;
    case 9735: handleZapReceipt(event); break;
  }
}

function handleMetadata(event) {
  try {
    const meta = JSON.parse(event.content);
    pubkeyToAgent[event.pubkey] = meta;
    AGENTS[event.pubkey] = meta;
  } catch (e) {}
}

function getAgentName(pubkey) {
  const agent = AGENTS[pubkey];
  if (agent) return agent.name || pubkey.slice(0, 8);
  return pubkey.slice(0, 8) + "...";
}

function formatTime(ts) {
  const d = ts ? new Date(ts * 1000) : new Date();
  return d.toLocaleTimeString("ja-JP", { hour: "2-digit", minute: "2-digit", second: "2-digit" });
}

// Kind:1 Chat
function handleChat(event) {
  const name = getCuteNameByPubkey(event.pubkey);
  const isOwner = ownerCrypto && event.pubkey === ownerCrypto.pubHex;
  const nameClass = isOwner ? "owner-label" : "chat-name";
  const div = document.createElement("div");
  div.className = "chat-msg";
  div.innerHTML = `<span class="chat-time">${formatTime(event.created_at)}</span><span class="${nameClass}">${escapeHtml(name)}</span><span class="chat-content">${escapeHtml(event.content)}</span>`;
  chatFeed.prepend(div);
  trimFeed(chatFeed, MAX_FEED);
}

// Kind:30078 Marketplace listings
function handleListing(event) {
  try {
    const content = JSON.parse(event.content);
    const dTag = getTag(event, "d") || event.id;
    const priceTag = getTag(event, "price");

    listings[dTag] = {
      id: dTag,
      name: content.name,
      description: content.description,
      language: content.language,
      price: content.price_sats || parseInt(priceTag) || 0,
      seller: event.pubkey,
      seller_name: getAgentName(event.pubkey),
      category: content.category || getTag(event, "t") || "unknown",
      created_at: event.created_at,
    };

    renderMarketplace();
  } catch (e) {}
}

function renderMarketplace() {
  const sorted = Object.values(listings).sort((a, b) => b.created_at - a.created_at);
  const existingIds = new Set();

  for (let idx = 0; idx < sorted.length; idx++) {
    const l = sorted[idx];
    existingIds.add(l.id);
    let card = marketplace.querySelector(`[data-listing="${l.id}"]`);
    if (!card) {
      card = document.createElement("div");
      card.className = "listing-card";
      card.dataset.listing = l.id;
      if (idx < marketplace.children.length) {
        marketplace.insertBefore(card, marketplace.children[idx]);
      } else {
        marketplace.appendChild(card);
      }
    }
    card.innerHTML = `
      <div style="display:flex;justify-content:space-between;align-items:center">
        <span class="listing-name">${escapeHtml(l.name)}</span>
        <span class="listing-price">${l.price} sats</span>
      </div>
      <div class="listing-meta">
        <span class="listing-seller">${escapeHtml(l.seller_name)}</span>
        <span class="listing-category">${escapeHtml(l.category)}</span>
      </div>`;
  }
  // Remove stale cards
  for (const card of [...marketplace.children]) {
    if (card.dataset.listing && !existingIds.has(card.dataset.listing)) {
      card.remove();
    }
  }
}

// Trade events
function handleTradeOffer(event) {
  tradeCount++;
  statTrades.textContent = tradeCount;
  try {
    const content = JSON.parse(event.content);
    const buyer = getAgentName(event.pubkey);
    const seller = getAgentName(getTag(event, "p"));
    addTradeEntry("trade-offer",
      `${buyer} offered ${content.offer_sats} sats to ${seller} for ${content.listing_id}`, event.created_at);
  } catch (e) {}
}

function handleTradeAccept(event) {
  try {
    const content = JSON.parse(event.content);
    const seller = getAgentName(event.pubkey);
    const buyer = getAgentName(getTag(event, "p"));
    addTradeEntry("trade-accept",
      `${seller} accepted offer from ${buyer} (${content.accepted_sats} sats)`, event.created_at);
  } catch (e) {}
}

function handleTradeReject(event) {
  try {
    const content = JSON.parse(event.content);
    const seller = getAgentName(event.pubkey);
    const buyer = getAgentName(getTag(event, "p"));
    addTradeEntry("trade-reject",
      `${seller} rejected offer from ${buyer}: ${content.reason || ""}`, event.created_at);
  } catch (e) {}
}

function handleTradePayment(event) {
  const buyer = getAgentName(event.pubkey);
  const seller = getAgentName(getTag(event, "p"));
  addTradeEntry("trade-payment",
    `${buyer} sent payment to ${seller} [encrypted]`, event.created_at);
}

function handleDelivery(event) {
  const seller = getAgentName(event.pubkey);
  const buyer = getAgentName(getTag(event, "p"));
  addTradeEntry("trade-delivery",
    `${seller} delivered program to ${buyer} [encrypted]`, event.created_at);
}

function handleTradeComplete(event) {
  try {
    const content = JSON.parse(event.content);
    const buyer = getAgentName(event.pubkey);
    const seller = getAgentName(getTag(event, "p"));
    addTradeEntry("trade-complete",
      `Trade complete! ${buyer} confirmed receipt from ${seller}`, event.created_at);
  } catch (e) {}
}

function handleZapReceipt(event) {
  try {
    const content = JSON.parse(event.content);
    const recipient = getAgentName(getTag(event, "p"));
    const sender = getAgentName(getTag(event, "P"));
    const amount = content.amount_sats || "?";
    addTradeEntry("trade-zap",
      `ZAP: ${sender} -> ${recipient}: ${amount} sats`, event.created_at);
  } catch (e) {}
}

function addTradeEntry(className, text, ts) {
  const div = document.createElement("div");
  div.className = "trade-entry";
  div.innerHTML = `<span class="trade-time">${formatTime(ts)}</span><span class="${className}">${escapeHtml(text)}</span>`;
  tradeFeed.prepend(div);
  trimFeed(tradeFeed, MAX_FEED);
}

// Kind:4300 Agent Status
function handleStatusBroadcast(event) {
  try {
    const content = JSON.parse(event.content);
    const agentName = getTag(event, "agent_name") || getAgentName(event.pubkey);
    const newTs = event.created_at || 0;

    // Track pubkey -> userName mapping for chat name resolution
    pubkeyToUserName[event.pubkey] = agentName;

    const existing = agentStatuses[agentName];
    // Only update if newer than existing data
    if (existing && existing.ts && existing.ts > newTs) return;
    agentStatuses[agentName] = {
      name: agentName,
      pubkey: event.pubkey,
      balance: content.balance_sats,
      programs_owned: content.programs_owned,
      programs_listed: content.programs_listed,
      active_trades: content.active_trades,
      last_action: content.last_action,
      tick_count: content.tick_count,
      ts: newTs,
    };
    renderAgentTable();

    // Record raw balance event for chart (uses all events, not just latest)
    recordBalanceEvent(newTs, agentName, content.balance_sats || 0);
  } catch (e) {}
}

// Kind:4301 Treasury Status
function handleTreasuryBroadcast(event) {
  try {
    const content = JSON.parse(event.content);
    statTreasury.textContent = (content.total_sats || 0).toLocaleString();
  } catch (e) {}
}

function renderAgentTable() {
  const agents = Object.values(agentStatuses).sort((a, b) => {
    const aIdx = parseInt((a.name.match(/user(\d+)/) || [])[1] || "99");
    const bIdx = parseInt((b.name.match(/user(\d+)/) || [])[1] || "99");
    return aIdx - bIdx;
  });

  let totalBalance = 0;
  for (let idx = 0; idx < agents.length; idx++) {
    const a = agents[idx];
    totalBalance += a.balance || 0;
    const personality = getPersonality(a.name);
    const pClass = personality ? `personality-${personality}` : "";
    const ago = Math.floor((Date.now() / 1000) - (a.ts || 0));
    const agoStr = ago < 60 ? `${ago}s ago` : `${Math.floor(ago/60)}m ago`;
    const cuteName = getCuteName(a.name);

    let row = agentTableBody.children[idx];
    if (!row) {
      row = document.createElement("tr");
      row.dataset.agent = a.name;
      for (let c = 0; c < 6; c++) row.appendChild(document.createElement("td"));
      agentTableBody.appendChild(row);
    }
    const cells = row.children;
    cells[0].innerHTML = `<span class="agent-name">${escapeHtml(cuteName || a.name)}</span><br><span style="color:var(--text2);font-size:11px">${escapeHtml(a.name)}</span>`;
    cells[1].innerHTML = `<span class="personality-tag ${pClass}">${personality || "?"}</span>`;
    cells[2].className = "balance";
    cells[2].textContent = `${(a.balance || 0).toLocaleString()} sats`;
    cells[3].textContent = `${a.programs_owned || 0} / ${a.programs_listed || 0}`;
    cells[4].textContent = `${a.active_trades || 0}`;
    cells[5].innerHTML = `<span style="color:var(--text2)">${escapeHtml(a.last_action || "idle")}</span><br><span style="font-size:10px;color:var(--text2)">${agoStr}</span>`;
  }
  statSupply.textContent = totalBalance > 0 ? totalBalance.toLocaleString() : "-";
}

function getPersonality(agentName) {
  const match = agentName.match(/user(\d+)/);
  if (!match) return null;
  const idx = parseInt(match[1]);
  return (AGENT_NAMES[idx] || {}).personality || null;
}

function getCuteName(agentName) {
  const match = agentName.match(/user(\d+)/);
  if (!match) return null;
  const idx = parseInt(match[1]);
  return (AGENT_NAMES[idx] || {}).name || null;
}

function getCuteNameByPubkey(pubkey) {
  const userName = pubkeyToUserName[pubkey];
  if (userName) {
    return getCuteName(userName) || userName;
  }
  const agent = AGENTS[pubkey];
  if (agent && agent.name) {
    const cute = getCuteName(agent.name);
    return cute || agent.name;
  }
  return pubkey.slice(0, 8);
}

// Helpers
function getTag(event, tagName) {
  if (!event.tags) return null;
  for (const t of event.tags) {
    if (t[0] === tagName && t.length > 1) return t[1];
  }
  return null;
}

function escapeHtml(text) {
  if (!text) return "";
  const div = document.createElement("div");
  div.textContent = text;
  return div.innerHTML;
}

function trimFeed(el, max) {
  while (el.children.length > max) {
    el.removeChild(el.lastChild);
  }
}

// ---- Balance History Chart ----
// Store raw kind:4300 events individually
let rawStatusEvents = []; // { ts, agent, balance }
let chartDirty = false;

function recordBalanceEvent(ts, agentName, balance) {
  rawStatusEvents.push({ ts, agent: agentName, balance });
  chartDirty = true;
  // Debounce rebuild (batch initial load)
  if (!recordBalanceEvent._timer) {
    recordBalanceEvent._timer = setTimeout(() => {
      recordBalanceEvent._timer = null;
      if (chartDirty) { rebuildBalanceHistory(); chartDirty = false; }
    }, 200);
  }
}

function rebuildBalanceHistory() {
  // Sort all raw events chronologically
  rawStatusEvents.sort((a, b) => a.ts - b.ts);

  // Walk through chronologically, tracking each agent's latest known balance
  const running = {};
  for (let i = 0; i < 10; i++) running[`user${i}`] = 0;

  balanceHistory = [];
  let prevTs = -1;
  for (const evt of rawStatusEvents) {
    running[evt.agent] = evt.balance;
    if (evt.ts === prevTs) {
      // Same timestamp: overwrite last snapshot
      balanceHistory[balanceHistory.length - 1].balances = { ...running };
    } else {
      balanceHistory.push({ ts: evt.ts, balances: { ...running } });
      prevTs = evt.ts;
    }
  }
  renderChart();
}

function renderChart() {
  if (balanceHistory.length < 2) return;

  const canvas = distChart;
  const container = canvas.parentElement;
  const rect = container.getBoundingClientRect();
  const dpr = window.devicePixelRatio || 1;
  canvas.width = rect.width * dpr;
  canvas.height = rect.height * dpr;
  const ctx = canvas.getContext("2d");
  ctx.scale(dpr, dpr);
  const W = rect.width;
  const H = rect.height;

  const PAD_LEFT = 50;
  const PAD_RIGHT = 80;
  const PAD_TOP = 10;
  const PAD_BOTTOM = 30;
  const plotW = W - PAD_LEFT - PAD_RIGHT;
  const plotH = H - PAD_TOP - PAD_BOTTOM;

  ctx.clearRect(0, 0, W, H);

  const agents = [];
  for (let i = 0; i < 10; i++) agents.push(`user${i}`);

  const data = balanceHistory;
  const n = data.length;
  const tsMin = data[0].ts;
  const tsMax = data[n - 1].ts;
  const tsRange = tsMax - tsMin || 1;

  // Compute totals and percentages
  const percentages = data.map(snap => {
    let total = 0;
    for (const a of agents) total += snap.balances[a] || 0;
    const pcts = {};
    for (const a of agents) pcts[a] = total > 0 ? (snap.balances[a] || 0) / total : 0;
    return pcts;
  });

  // Draw stacked areas (bottom to top)
  for (let ai = agents.length - 1; ai >= 0; ai--) {
    ctx.beginPath();
    // Top edge (cumulative from agent 0 to ai)
    for (let di = 0; di < n; di++) {
      let cumTop = 0;
      for (let j = 0; j <= ai; j++) cumTop += percentages[di][agents[j]];
      const x = PAD_LEFT + ((data[di].ts - tsMin) / tsRange) * plotW;
      const y = PAD_TOP + plotH * (1 - cumTop);
      if (di === 0) ctx.moveTo(x, y);
      else ctx.lineTo(x, y);
    }
    // Bottom edge (cumulative from agent 0 to ai-1), reversed
    for (let di = n - 1; di >= 0; di--) {
      let cumBot = 0;
      for (let j = 0; j < ai; j++) cumBot += percentages[di][agents[j]];
      const x = PAD_LEFT + ((data[di].ts - tsMin) / tsRange) * plotW;
      const y = PAD_TOP + plotH * (1 - cumBot);
      ctx.lineTo(x, y);
    }
    ctx.closePath();
    ctx.fillStyle = AGENT_COLORS[ai];
    ctx.globalAlpha = 0.85;
    ctx.fill();
    ctx.globalAlpha = 1;
  }

  // Y-axis labels
  ctx.fillStyle = "#8b949e";
  ctx.font = "10px monospace";
  ctx.textAlign = "right";
  for (let p = 0; p <= 100; p += 25) {
    const y = PAD_TOP + plotH * (1 - p / 100);
    ctx.fillText(`${p}%`, PAD_LEFT - 6, y + 3);
    ctx.strokeStyle = "#30363d";
    ctx.lineWidth = 0.5;
    ctx.beginPath();
    ctx.moveTo(PAD_LEFT, y);
    ctx.lineTo(PAD_LEFT + plotW, y);
    ctx.stroke();
  }

  // X-axis labels
  ctx.textAlign = "center";
  const labelCount = Math.min(6, n);
  for (let i = 0; i < labelCount; i++) {
    const di = Math.floor(i * (n - 1) / (labelCount - 1));
    const x = PAD_LEFT + ((data[di].ts - tsMin) / tsRange) * plotW;
    const y = PAD_TOP + plotH + 16;
    const d = new Date(data[di].ts * 1000);
    ctx.fillText(d.toLocaleTimeString("ja-JP", { hour: "2-digit", minute: "2-digit" }), x, y);
  }

  // Agent names on right edge of chart
  const lastPcts = percentages[n - 1];
  ctx.font = "bold 11px monospace";
  ctx.textAlign = "left";
  for (let ai = 0; ai < agents.length; ai++) {
    let cumBot = 0;
    for (let j = 0; j < ai; j++) cumBot += lastPcts[agents[j]];
    let cumTop = cumBot + lastPcts[agents[ai]];
    const bandMidY = PAD_TOP + plotH * (1 - (cumBot + cumTop) / 2);
    const bandH = plotH * lastPcts[agents[ai]];
    // Only draw name if band is tall enough
    if (bandH < 8) continue;
    const cute = AGENT_NAMES[ai].name;
    const labelX = PAD_LEFT + plotW + 6;
    ctx.fillStyle = AGENT_COLORS[ai];
    ctx.fillText(cute, labelX, bandMidY + 4);
  }
}

// Resize chart on window resize
window.addEventListener("resize", () => { if (balanceHistory.length >= 2) renderChart(); });

// Initialize: render empty table with known agents
function initAgentTable() {
  for (let i = 0; i < 10; i++) {
    const a = AGENT_NAMES[i];
    agentStatuses[`user${i}`] = {
      name: `user${i}`,
      balance: 0,
      programs_owned: 0,
      programs_listed: 0,
      active_trades: 0,
      last_action: "waiting...",
      ts: 0,
    };
  }
  renderAgentTable();
}

// ---- Owner Chat (kind:1 posting via noble-curves) ----
const OWNER_NAME = "オーナー";
let ownerCrypto = null;
const chatInput = document.getElementById("chatInput");
const chatSend = document.getElementById("chatSend");

// Sync: register owner pubkey from localStorage before any events arrive
{
  const cachedPub = localStorage.getItem("owner_pubhex");
  if (cachedPub) {
    pubkeyToUserName[cachedPub] = OWNER_NAME;
    AGENTS[cachedPub] = { name: OWNER_NAME };
  }
}

async function initOwnerCrypto() {
  try {
    const { schnorr } = await import("https://esm.sh/@noble/curves@1.8.1/secp256k1");
    const { sha256 } = await import("https://esm.sh/@noble/hashes@1.7.1/sha256");
    const { bytesToHex, randomBytes } = await import("https://esm.sh/@noble/hashes@1.7.1/utils");

    let privHex = localStorage.getItem("owner_privkey");
    if (!privHex) {
      privHex = bytesToHex(randomBytes(32));
      localStorage.setItem("owner_privkey", privHex);
    }
    const pubHex = bytesToHex(schnorr.getPublicKey(privHex));

    ownerCrypto = { schnorr, sha256, bytesToHex, privHex, pubHex };

    // Register owner name + cache pubkey for future loads
    pubkeyToUserName[pubHex] = OWNER_NAME;
    AGENTS[pubHex] = { name: OWNER_NAME };
    localStorage.setItem("owner_pubhex", pubHex);

    chatSend.disabled = false;
  } catch (e) {
    console.error("Failed to load crypto:", e);
  }
}

async function publishOwnerChat(content) {
  if (!ownerCrypto || !ws || ws.readyState !== 1) return;
  const { schnorr, sha256, bytesToHex, privHex, pubHex } = ownerCrypto;

  const event = {
    pubkey: pubHex,
    created_at: Math.floor(Date.now() / 1000),
    kind: 1,
    tags: [],
    content: content,
  };
  const serialized = JSON.stringify([
    0, event.pubkey, event.created_at, event.kind, event.tags, event.content
  ]);
  const hash = sha256(new TextEncoder().encode(serialized));
  event.id = bytesToHex(hash);
  event.sig = bytesToHex(schnorr.sign(hash, privHex));

  ws.send(JSON.stringify(["EVENT", event]));
}

chatSend.addEventListener("click", () => {
  const msg = chatInput.value.trim();
  if (!msg) return;
  publishOwnerChat(msg);
  chatInput.value = "";
});

chatInput.addEventListener("keydown", (e) => {
  if (e.key === "Enter" && !e.isComposing) {
    e.preventDefault();
    chatSend.click();
  }
});

initAgentTable();
connect();
initOwnerCrypto();
</script>
</body>
</html>
